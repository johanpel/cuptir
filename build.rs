use std::{io::Write, path::PathBuf};

use convert_case::{Boundary, Case};
use quote::{format_ident, quote};
use syn::Ident;

fn longest_common_prefix(items: &[Ident]) -> String {
    if items.len() == 0 {
        return Default::default();
    } else {
        let mut longest = items[0].to_string();
        for item in items {
            while !item.to_string().starts_with(&longest) {
                longest.pop();
                if longest.is_empty() {
                    return longest;
                }
            }
        }
        longest
    }
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut _debug = std::fs::File::create("build_debug.log")?;

    println!("cargo::rerun-if-changed=src/gen/wrapper.h");

    // Setup bindgen
    let mut builder = bindgen::Builder::default()
        .header("src/gen/wrapper.h")
        .clang_arg("-I/usr/local/cuda/targets/x86_64-linux/include/") // TODO works on my machine :tm:
        .parse_callbacks(Box::new(bindgen::CargoCallbacks::new()))
        .default_enum_style(bindgen::EnumVariation::Rust {
            non_exhaustive: false,
        })
        .derive_default(true)
        .derive_eq(true)
        .derive_hash(true)
        .derive_ord(true)
        // .generate_comments(false)
        .layout_tests(false)
        .allowlist_recursively(false)
        .generate_comments(true)
        .use_core();
    for expr in [
        "^[Cc][Uu][Pp][Tt][Ii].*",
        "^[Cc][Uu][Dd][Aa].*_params.*",
        "^[Cc][Uu].*_params.*",
        "CUDA_ARRAY_DESCRIPTOR_v1_st",
        "CUDA_ARRAY_DESCRIPTOR_v1",
        "CUDA_ARRAY3D_DESCRIPTOR_v1_st",
        "CUDA_ARRAY3D_DESCRIPTOR_v1",
        "CUDA_MEMCPY2D_v1_st",
        "CUDA_MEMCPY2D_v1",
        "CUDA_MEMCPY3D_v1_st",
        "CUDA_MEMCPY3D_v1",
        "CUdeviceptr_v1",
    ] {
        builder = builder.allowlist_type(expr);
    }
    for expr in ["^cupti.*"] {
        builder = builder.allowlist_function(expr);
    }
    for expr in ["^[Cc][Uu][Pp][Tt][Ii].*"] {
        builder = builder.allowlist_var(expr);
    }
    for expr in [
        "use cudarc::driver::sys::*;",
        "use cudarc::runtime::sys::*;",
    ] {
        builder = builder.raw_line(expr);
    }

    let bindgen_bindings = builder.generate()?;
    let mut bindgen_output = vec![];
    bindgen_bindings.write(Box::new(&mut bindgen_output))?;

    // Set up case converters for enums.
    let enum_ident_case_converter = convert_case::Converter::new()
        .add_boundaries(&[Boundary::LOWER_UPPER])
        .to_case(Case::Pascal);
    let enum_variant_case_converter = convert_case::Converter::new()
        .add_boundaries(&[Boundary::UNDERSCORE])
        .to_case(Case::Pascal);

    // Parse the source generated by bindgen
    let source = syn::parse_file(String::from_utf8(bindgen_output)?.as_str())?;

    // Generate Rusty enum types for all enum generated by bindgen.
    let mut enum_decls = vec![];
    source.items.iter().try_for_each(|item| {
        match item {
            syn::Item::Enum(item_enum) => {
                let source_name = item_enum.ident.to_string();
                if source_name.starts_with("CUpti_") {
                    if let Some((_, rest)) = source_name.split_once("CUpti_") {
                        let source_variants = item_enum
                            .variants
                            .iter()
                            .map(|variant| variant.ident.clone())
                            .collect::<Vec<_>>();

                        let target_ident =
                            format_ident!("{}", enum_ident_case_converter.convert(rest));

                        // Determine the longest common prefix for the enum variants,
                        // which we will strip off. Luckily, CUPTI enum variant
                        // declarations are very consistent about this.
                        let prefix = longest_common_prefix(&source_variants);

                        let mut variants = vec![];
                        let mut sentinels = vec![];
                        for source_variant in source_variants {
                            // Remove the common prefix from the variant. E.g. for the
                            // bindgen generated enum `CUpti_CallbackIdResource` it would
                            // be "CUPTI_CBID_RESOURCE_". This is our target variant.
                            let target_variant = source_variant
                                .to_string()
                                .strip_prefix(&prefix)
                                .unwrap()
                                .to_owned();

                            // CUPTI often declares three sentinel variants.
                            // - <X>_INVALID, with underlying value 0,
                            // - <X>_SIZE, to help determine the number of valid
                            //   variants within an enum,
                            // - <X>_FORCE_INT, to force the C compiler to use a 32-bit
                            //   representation as underlying type.
                            //
                            // We're removing these such that clients of the safe Rust
                            // wrapper can't erroneously use these sentinels.
                            let source_ident = item_enum.ident.clone();
                            if !(target_variant.eq("INVALID")
                                || target_variant.eq("SIZE")
                                || target_variant.contains("FORCE_INT"))
                            {
                                let source_variant = format_ident!("{}", source_variant);
                                let target_variant = format_ident!(
                                    "{}",
                                    enum_variant_case_converter.convert(target_variant)
                                );
                                let variant = quote! {
                                    #target_variant = sys::#source_ident::#source_variant as u32
                                };
                                variants.push(variant);
                            } else {
                                let match_sentinel = quote! {
                                    sys::#source_ident::#source_variant => Err(CuptirError::SentinelEnum(value as u32))
                                };
                                sentinels.push(match_sentinel);
                            }
                        }

                        let source_ident = item_enum.ident.clone();
                        let enum_decl = quote! {
                            #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq, FromRepr)]
                            #[cfg_attr(feature = "serde", derive(Deserialize, Serialize))]
                            #[repr(u32)]
                            pub enum #target_ident {
                                #(#variants),*
                            }

                            impl TryFrom<sys::#source_ident> for #target_ident {
                                type Error = CuptirError;

                                fn try_from(value: sys::#source_ident) -> Result<Self, CuptirError> {
                                    match value {
                                        #(#sentinels,)*
                                        other => { Self::from_repr(other as u32).ok_or(CuptirError::Corrupted) }
                                    }
                                }
                            }

                            impl From<#target_ident> for sys::#source_ident {
                                fn from(value: #target_ident) -> Self {
                                    unsafe { std::mem::transmute::<u32, Self>(value as u32) }
                                }
                            }

                        };
                        enum_decls.push(enum_decl);
                    }
                }
            }
            _ => (),
        };
        Ok::<(), Box<dyn std::error::Error>>(())
    })?;

    let tokens = quote! {
        use cudarc::cupti::sys;
        #[cfg(feature = "serde")]
        use serde::{Deserialize, Serialize};
        use strum::FromRepr;

        use crate::CuptirError;

        #(#enum_decls)*
    };

    let syntax_tree = syn::parse2(tokens)?;
    let target = prettyplease::unparse(&syntax_tree);

    let root = PathBuf::from(std::env::var("OUT_DIR")?);
    let output_path = root.join("enums.rs");

    writeln!(
        _debug,
        "Enums written to: {}",
        output_path.to_str().unwrap()
    )?;

    let mut output = std::fs::File::create(output_path)?;
    output.write(target.as_bytes())?;

    Ok(())
}
