use std::{io::Write, path::PathBuf};

use convert_case::{Boundary, Case};
use proc_macro2::TokenStream;
use quote::{format_ident, quote};
use syn::Ident;

fn longest_common_prefix(items: &[Ident]) -> String {
    if items.is_empty() {
        Default::default()
    } else {
        let mut longest = items[0].to_string();
        for item in items {
            while !item.to_string().starts_with(&longest) {
                longest.pop();
                if longest.is_empty() {
                    return longest;
                }
            }
        }
        longest
    }
}

fn generate_safe_enums(source: &syn::File) -> TokenStream {
        // Set up case converters for enums.
    let enum_ident_case_converter = convert_case::Converter::new()
        .add_boundaries(&[Boundary::LOWER_UPPER])
        .to_case(Case::Pascal);
    let enum_variant_case_converter = convert_case::Converter::new()
        .add_boundaries(&[Boundary::UNDERSCORE])
        .to_case(Case::Pascal);

    // Generate Rusty enum types for all enum generated by bindgen.
    let mut enum_decls = vec![];
    source.items.iter().for_each(|item|         
        if let syn::Item::Enum(src_enum) = item {
            let src_enum_name = src_enum.ident.to_string();
            if src_enum_name.starts_with("CUpti_") {
                if let Some((_, rest)) = src_enum_name.split_once("CUpti_") {
                    let src_enum_variants = src_enum
                        .variants
                        .iter()
                        .map(|src_variant| src_variant.ident.clone())
                        .collect::<Vec<_>>();

                    let tgt_enum_name = enum_ident_case_converter
                        .convert(rest)
                        // Special case for the enum related to callback ids, it has
                        // an ugly suffix:
                        .replace("ApiTraceCbidEnum", "Func");

                    // Remember whether we're dealing with a special case.
                    let is_api_func = tgt_enum_name.eq("DriverFunc") || tgt_enum_name.eq("RuntimeFunc");

                    let tgt_enum_ident = format_ident!("{tgt_enum_name}");

                    // Determine the longest common prefix for the enum variants,
                    // which we will strip off. Luckily, CUPTI enum variant
                    // declarations are very consistent about this.
                    let prefix = longest_common_prefix(&src_enum_variants);

                    let mut tgt_variants = vec![];
                    let mut tgt_sentinels = vec![];
                    for src_variant in src_enum_variants {
                        // Remove the common prefix from the variant. E.g. for the
                        // bindgen generated enum `CUpti_CallbackIdResource` it
                        // would be "CUPTI_CBID_RESOURCE_".
                        let tgt_variant_name = src_variant
                            .to_string()
                            .strip_prefix(&prefix)
                            .unwrap()
                            .to_owned();

                        // CUPTI often declares three sentinel variants.
                        // - <X>_INVALID, with underlying value 0,
                        // - <X>_SIZE, to help determine the number of valid
                        //   variants within an enum,
                        // - <X>_FORCE_INT, to force the C compiler to use a 32-bit
                        //   representation as underlying type.
                        //
                        // We're removing these such that clients of the safe Rust
                        // wrapper can't erroneously use these sentinels.
                        let src_ident = src_enum.ident.clone();
                        if !(tgt_variant_name.eq("INVALID")
                            || tgt_variant_name.eq("SIZE")
                            || tgt_variant_name.contains("FORCE_INT"))
                        {
                            let src_variant_ident = format_ident!("{}", src_variant);
                            // Special case for the callback names, we want to
                            // retain their case style so they are easy to look up
                            // in cuda docs.
                            let tgt_variant_ident = 
                            format_ident!("{}", 
                                if is_api_func {
                                    tgt_variant_name
                                } else {
                                    enum_variant_case_converter.convert(tgt_variant_name)
                                }
                            );
                            let variant = quote! {
                                #tgt_variant_ident = sys::#src_ident::#src_variant_ident as u32
                            };
                            tgt_variants.push(variant);
                        } else {
                            let match_sentinel = quote! {
                                sys::#src_ident::#src_variant => Err(CuptirError::SentinelEnum(value as u32))
                            };
                            tgt_sentinels.push(match_sentinel);
                        }
                    }

                    let allow_non_camel = if is_api_func { quote! { #[allow(non_camel_case_types)] } } else { quote!{} };

                    let source_ident = src_enum.ident.clone();
                    let conversions_try_from = if tgt_sentinels.is_empty() {
                        quote! {
                            fn try_from(value: sys::#source_ident) -> Result<Self, CuptirError> {
                                Self::from_repr(value as u32).ok_or(CuptirError::Corrupted)
                            }
                        }
                    } else {
                        quote! {
                            fn try_from(value: sys::#source_ident) -> Result<Self, CuptirError> {
                                match value {
                                    #(#tgt_sentinels,)*
                                    other => { Self::from_repr(other as u32).ok_or(CuptirError::Corrupted) }
                                }
                            }
                        }
                    };

                    let conversions = quote! {
                        impl TryFrom<sys::#source_ident> for #tgt_enum_ident {
                            type Error = CuptirError;
                            #conversions_try_from
                        }

                        impl From<#tgt_enum_ident> for sys::#source_ident {
                            fn from(value: #tgt_enum_ident) -> Self {
                                unsafe { std::mem::transmute::<u32, Self>(value as u32) }
                            }
                        }
                    };

                    let enum_decl = quote! {
                        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq, FromRepr)]
                        #[cfg_attr(feature = "serde", derive(Deserialize, Serialize))]
                        #allow_non_camel
                        #[repr(u32)]
                        pub enum #tgt_enum_ident {
                            #(#tgt_variants),*
                        }

                        #conversions
                    };

                    enum_decls.push(enum_decl);
                }
            }
        }
    );

    quote! {
        use cudarc::cupti::sys;
        #[cfg(feature = "serde")]
        use serde::{Deserialize, Serialize};
        use strum::FromRepr;

        use crate::CuptirError;

        #(#enum_decls)*
    }
}

fn generate_function_param_structs(source: &syn::File) -> TokenStream {
    let mut driver_variants = vec![];
    let mut driver_matchers = vec![];
    let mut runtime_variants = vec![]; 
    let mut runtime_matchers = vec![]; 
    source.items.iter().for_each(|item| 
        if let syn::Item::Struct(src_struct) = item {
            let src_struct_name = src_struct.ident.to_string();
            if src_struct_name.ends_with("_params_st") {
                let cuda_func_name = src_struct_name.strip_suffix("_params_st").unwrap().to_owned();
                let cuda_func_variant_ident = format_ident!("{cuda_func_name}");

                let struct_type_alias_name = src_struct_name.strip_suffix("_st").unwrap().to_owned();
                let struct_type_ident = format_ident!("{struct_type_alias_name}");

                let enum_variant = quote! { 
                    #cuda_func_variant_ident(*const #struct_type_ident)
                };
                let matcher = |which: &str| {
                    let e = format_ident!("{which}Func");
                    quote! { 
                        #e::#cuda_func_variant_ident => Self::#cuda_func_variant_ident(params as *const #struct_type_ident)
                    }
                };

                // Prepare variants for the enums.
                if cuda_func_name.starts_with("cuda") {
                    runtime_variants.push(enum_variant);
                    runtime_matchers.push(matcher("Runtime"));
                } else if cuda_func_name.starts_with("cu") {
                    driver_variants.push(enum_variant);
                    driver_matchers.push(matcher("Driver"));
                }
            }
        },
    );

    quote! {
        use cudarc::cupti::sys::*;
        
        use crate::{CuptirError, enums::{RuntimeFunc, DriverFunc}};

        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        #[allow(non_camel_case_types)]
        pub enum DriverFunctionParams {
            #(#driver_variants),*
        }

        impl DriverFunctionParams {
            pub fn try_new(
                function: DriverFunc,
                params: *const std::ffi::c_void,
            ) -> Result<Self, CuptirError> {
                Ok(match function {
                    #(#driver_matchers,)*
                    _ => Err(CuptirError::CuptiNotSupported)?
                })
            }
        }

        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        #[allow(non_camel_case_types)]
        pub enum RuntimeFunctionParams {
            #(#runtime_variants),*
        }

        impl RuntimeFunctionParams {
            pub fn try_new(
                function: RuntimeFunc,
                params: *const std::ffi::c_void,
            ) -> Result<Self, CuptirError> {
                Ok(match function {
                    #(#runtime_matchers,)*
                    _ => Err(CuptirError::CuptiNotSupported)?
                })
            }
        }
    }
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let trace = std::fs::File::create("build_trace.log")?;
    tracing_subscriber::fmt()
        .with_writer(trace)
        .with_ansi(false)
        .with_env_filter(tracing_subscriber::EnvFilter::new("off,build_script_build=trace"))
        .init();

    println!("cargo::rerun-if-changed=src/gen/wrapper.h");

    // Setup bindgen similar to cudarc so we can potentially upstream this later.
    let mut builder = bindgen::Builder::default()
        .header("src/gen/wrapper.h")
        .clang_arg("-I/usr/local/cuda/targets/x86_64-linux/include/") // TODO works on my machine :tm:
        .parse_callbacks(Box::new(bindgen::CargoCallbacks::new()))
        .default_enum_style(bindgen::EnumVariation::Rust {
            non_exhaustive: false,
        })
        .derive_default(true)
        .derive_eq(true)
        .derive_hash(true)
        .derive_ord(true)
        // .generate_comments(false)
        .layout_tests(false)
        .allowlist_recursively(false)
        .generate_comments(true)
        .use_core();
    for expr in [
        "^[Cc][Uu][Pp][Tt][Ii].*",
        "^[Cc][Uu][Dd][Aa].*_params.*",
        "^[Cc][Uu].*_params.*",
        "CUDA_ARRAY_DESCRIPTOR_v1_st",
        "CUDA_ARRAY_DESCRIPTOR_v1",
        "CUDA_ARRAY3D_DESCRIPTOR_v1_st",
        "CUDA_ARRAY3D_DESCRIPTOR_v1",
        "CUDA_MEMCPY2D_v1_st",
        "CUDA_MEMCPY2D_v1",
        "CUDA_MEMCPY3D_v1_st",
        "CUDA_MEMCPY3D_v1",
        "CUdeviceptr_v1",
    ] {
        builder = builder.allowlist_type(expr);
    }
    
    builder = builder.allowlist_function("^cupti.*");    
    builder = builder.allowlist_var("^[Cc][Uu][Pp][Tt][Ii].*");

    for expr in [
        "use cudarc::driver::sys::*;",
        "use cudarc::runtime::sys::*;",
    ] {
        builder = builder.raw_line(expr);
    }

    let bindgen_bindings = builder.generate()?;
    let mut bindgen_output = vec![];
    bindgen_bindings.write(Box::new(&mut bindgen_output))?;

    // Parse the source generated by bindgen
    let source = syn::parse_file(String::from_utf8(bindgen_output)?.as_str())?;

    // Generate targets
    let root = PathBuf::from(std::env::var("OUT_DIR")?);
    let targets = [
        (generate_safe_enums(&source), root.join("enums.rs")),
        (generate_function_param_structs(&source), root.join("function_params.rs"))
    ];

    // Write targets
    for (tokens, path) in targets {
        let mut output = std::fs::File::create(path)?;
        let syntax_tree = syn::parse2(tokens)?;
        let target = prettyplease::unparse(&syntax_tree);
        write!(output, "{target}")?;
    }

    Ok(())
}
