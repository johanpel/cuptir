use std::{
    fs::File,
    io::{Read, Write},
    path::PathBuf,
};

use convert_case::{Boundary, Case};
use proc_macro2::{TokenStream, TokenTree};
use quote::{format_ident, quote};
use syn::{Attribute, Ident, Meta};

fn longest_common_prefix(items: &[Ident]) -> String {
    if items.is_empty() {
        Default::default()
    } else {
        let mut longest = items[0].to_string();
        for item in items {
            while !item.to_string().starts_with(&longest) {
                longest.pop();
                if longest.is_empty() {
                    return longest;
                }
            }
        }
        longest
    }
}

// Get the enabled cuda-<version> feature from the env, if any
pub fn enabled_cuda_feature() -> Option<String> {
    let prefix = "CARGO_FEATURE_CUDA_";
    for (k, v) in std::env::vars() {
        if v == "1" && k.starts_with(prefix) {
            let feat = k
                .trim_start_matches("CARGO_FEATURE_")
                .to_lowercase()
                .replace('_', "-");
            return Some(feat);
        }
    }
    None
}

/// Extract CUDA version-related features from attributes.
pub fn extract_cuda_features(attr: &Attribute) -> Vec<String> {
    if !attr.path().is_ident("cfg") {
        return Vec::new();
    }
    let mut cuda_version_features = Vec::new();
    if let Meta::List(list) = &attr.meta {
        find_cuda_version_feature_in_stream(list.tokens.clone(), &mut cuda_version_features);
    }
    cuda_version_features
}

/// Given a token stream, figure out either top-level version strings or nested ones
/// that would appear in a cfg(any(...)) group.
fn find_cuda_version_feature_in_stream(token_stream: TokenStream, out: &mut Vec<String>) {
    for token_tree in token_stream {
        match token_tree {
            TokenTree::Group(group) => find_cuda_version_feature_in_stream(group.stream(), out),
            TokenTree::Literal(literal) => {
                if let Ok(literal_str) = syn::parse_str::<syn::LitStr>(&literal.to_string()) {
                    let value = literal_str.value();
                    if value.starts_with("cuda-") {
                        out.push(value);
                    }
                }
            }
            _ => {}
        }
    }
}

/// Determine whether to skip this item if it doesn't match the version we're building
/// for.
fn keep_item(version: &str, attrs: &[Attribute]) -> bool {
    if attrs.is_empty() {
        // It has no attributes so it can't be feature-gated by a cuda version feature,
        // so we want to keep it.
        true
    } else {
        let keep_mask = attrs
            .iter()
            .filter_map(|attr| {
                let features = extract_cuda_features(attr);
                if features.is_empty() {
                    // Not a cuda version feature related cfg attribute, so don't care.
                    None
                } else if features
                    .iter()
                    .map(String::as_str)
                    .any(|feature| feature == version)
                {
                    // A cuda version feature related cfg attribute matching our
                    // version.
                    Some(true)
                } else {
                    // A cuda version feature related cfg attribute not matching our
                    // version.
                    Some(false)
                }
            })
            .collect::<Vec<_>>();
        if keep_mask.is_empty() {
            // It had some attributes, but none related to a cuda version feature, so we
            // need to keep it.
            true
        } else {
            // There is at least one attribute which was a cuda version feature cfg.
            // Check whether any of them indicated we should keep this.
            keep_mask.into_iter().any(|v| v)
        }
    }
}

fn generate_safe_enums(source: &syn::File, version: &str) -> TokenStream {
    // Set up case converters for enums.
    let enum_ident_case_converter = convert_case::Converter::new()
        .add_boundaries(&[Boundary::LOWER_UPPER])
        .to_case(Case::Pascal);
    let enum_variant_case_converter = convert_case::Converter::new()
        .add_boundaries(&[Boundary::UNDERSCORE])
        .to_case(Case::Pascal);
    // Generate Rusty enum types for all enum generated by bindgen.
    let mut enum_decls = vec![];
    source.items.iter().for_each(|item|
        if let syn::Item::Enum(src_enum) = item {
            if !keep_item(version, &src_enum.attrs) {
                return;
            }

            let src_enum_name = src_enum.ident.to_string();
            if src_enum_name.starts_with("CUpti_")
                && let Some((_, rest)) = src_enum_name.split_once("CUpti_") {
                let src_enum_variants = src_enum
                    .variants
                    .iter()
                    .map(|src_variant| src_variant.ident.clone())
                    .collect::<Vec<_>>();

                let tgt_enum_name = enum_ident_case_converter
                    .convert(rest)
                    // Special case for the enum related to callback ids, it has
                    // an ugly suffix:
                    .replace("ApiTraceCbidEnum", "Func");

                // Remember whether we're dealing with a special case.
                let is_api_func = tgt_enum_name.eq("DriverFunc") || tgt_enum_name.eq("RuntimeFunc");

                let tgt_enum_ident = format_ident!("{tgt_enum_name}");

                // Determine the longest common prefix for the enum variants,
                // which we will strip off. Luckily, CUPTI enum variant
                // declarations are very consistent about this.
                let prefix = longest_common_prefix(&src_enum_variants);

                let mut tgt_variants = vec![];
                let mut tgt_sentinels = vec![];
                for src_variant in src_enum_variants {
                    // Remove the common prefix from the variant. E.g. for the
                    // bindgen generated enum `CUpti_CallbackIdResource` it
                    // would be "CUPTI_CBID_RESOURCE_".
                    let tgt_variant_name = src_variant
                        .to_string()
                        .strip_prefix(&prefix)
                        .unwrap()
                        .to_owned();

                    // CUPTI often declares some combination of four possible
                    // sentinel variants.
                    // - <X>_INVALID, with underlying value 0,
                    // - <X>_SIZE and <X>_COUNT, to help determine the number of
                    //   valid variants within an enum,
                    // - <X>_FORCE_INT, to force the C compiler to use a 32-bit
                    //   representation as underlying type.
                    //
                    // We're removing these such that clients of the safe Rust
                    // wrapper can't erroneously use these sentinels.
                    let src_ident = src_enum.ident.clone();
                    if !(tgt_variant_name.eq("INVALID")
                        || tgt_variant_name.eq("SIZE")
                        || tgt_variant_name.eq("COUNT")
                        || tgt_variant_name.contains("FORCE_INT"))
                    {
                        let src_variant_ident = format_ident!("{}", src_variant);
                        // Special case for the callback names, we want to
                        // retain their case style so they are easy to look up
                        // in cuda docs.
                        let tgt_variant_ident =
                            format_ident!("{}",
                                if is_api_func {
                                    tgt_variant_name
                                } else {
                                    enum_variant_case_converter.convert(tgt_variant_name)
                                }
                            );
                        let variant = quote! {
                            #tgt_variant_ident = sys::#src_ident::#src_variant_ident as u32
                        };
                        tgt_variants.push(variant);
                    } else {
                        let match_sentinel = quote! {
                            sys::#src_ident::#src_variant => Err(CuptirError::SentinelEnum(value as u32))
                        };
                        tgt_sentinels.push(match_sentinel);
                    }
                }

                let allow_non_camel = if is_api_func {
                    quote! { #[allow(non_camel_case_types)] }
                } else {
                    quote! {}
                };

                let source_ident = src_enum.ident.clone();
                let conversions_try_from = if tgt_sentinels.is_empty() {
                    quote! {
                        fn try_from(value: sys::#source_ident) -> Result<Self, CuptirError> {
                            Self::try_from(value as u32)
                        }
                    }
                } else {
                    quote! {
                        fn try_from(value: sys::#source_ident) -> Result<Self, CuptirError> {
                            match value {
                                #(#tgt_sentinels,)*
                                other => { Self::try_from(other as u32) }
                            }
                        }
                    }
                };
                let conversions = quote! {
                    impl TryFrom<sys::#source_ident> for #tgt_enum_ident {
                        type Error = CuptirError;
                        #conversions_try_from
                    }

                    impl From<#tgt_enum_ident> for sys::#source_ident {
                        fn from(value: #tgt_enum_ident) -> Self {
                            unsafe { std::mem::transmute::<u32, Self>(value as u32) }
                        }
                    }

                    impl From<#tgt_enum_ident> for u32 {
                        fn from(value: #tgt_enum_ident) -> Self {
                            value as u32
                        }
                    }

                    impl From<&#tgt_enum_ident> for u32 {
                        fn from(value: &#tgt_enum_ident) -> Self {
                            (*value) as u32
                        }
                    }

                    impl TryFrom<u32> for #tgt_enum_ident {
                        type Error = CuptirError;
                        fn try_from(value: u32) -> Result<Self, CuptirError> {
                            Self::from_repr(value).ok_or(CuptirError::Corrupted)
                        }

                    }
                };

                let enum_decl = quote! {
                    #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq, FromRepr)]
                    #[cfg_attr(feature = "serde", derive(Deserialize, Serialize))]
                    #allow_non_camel
                    #[repr(u32)]
                    pub enum #tgt_enum_ident {
                        #(#tgt_variants),*
                    }

                    #conversions
                };

                enum_decls.push(enum_decl);
            }
        }
    );

    quote! {
        use cudarc::cupti::sys;
        #[cfg(feature = "serde")]
        use serde::{Deserialize, Serialize};
        use strum::FromRepr;

        use crate::CuptirError;

        #(#enum_decls)*
    }
}

fn generate_function_param_structs(source: &syn::File, version: &str) -> TokenStream {
    let mut driver_variants = vec![];
    let mut driver_matchers = vec![];
    let mut runtime_variants = vec![];
    let mut runtime_matchers = vec![];
    source.items.iter().for_each(|item|
        if let syn::Item::Struct(src_struct) = item {
            if !keep_item(version, &src_struct.attrs) {
                return;
            }
            let src_struct_name = src_struct.ident.to_string();
            if src_struct_name.ends_with("_params_st") {
                let cuda_func_name = src_struct_name.strip_suffix("_params_st").unwrap().to_owned();
                let cuda_func_variant_ident = format_ident!("{cuda_func_name}");

                let struct_type_alias_name = src_struct_name.strip_suffix("_st").unwrap().to_owned();
                let struct_type_ident = format_ident!("{struct_type_alias_name}");

                let enum_variant = quote! {
                    #cuda_func_variant_ident(*const #struct_type_ident)
                };
                let matcher = |which: &str| {
                    let e = format_ident!("{which}Func");
                    quote! {
                        #e::#cuda_func_variant_ident => Self::#cuda_func_variant_ident(params as *const #struct_type_ident)
                    }
                };

                // Prepare variants for the enums.
                if cuda_func_name.starts_with("cuda") {
                    runtime_variants.push(enum_variant);
                    runtime_matchers.push(matcher("Runtime"));
                } else if cuda_func_name.starts_with("cu") {
                    driver_variants.push(enum_variant);
                    driver_matchers.push(matcher("Driver"));
                }
            }
        },
    );

    quote! {
        use cudarc::cupti::sys::*;

        use crate::{CuptirError, enums::{RuntimeFunc, DriverFunc}};

        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        #[allow(non_camel_case_types)]
        pub enum DriverFunctionParams {
            #(#driver_variants),*
        }

        impl DriverFunctionParams {
            pub fn try_new(
                function: DriverFunc,
                params: *const std::ffi::c_void,
            ) -> Result<Self, CuptirError> {
                Ok(match function {
                    #(#driver_matchers,)*
                    _ => Err(CuptirError::CuptiNotSupported)?
                })
            }
        }

        #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
        #[allow(non_camel_case_types)]
        pub enum RuntimeFunctionParams {
            #(#runtime_variants),*
        }

        impl RuntimeFunctionParams {
            pub fn try_new(
                function: RuntimeFunc,
                params: *const std::ffi::c_void,
            ) -> Result<Self, CuptirError> {
                Ok(match function {
                    #(#runtime_matchers,)*
                    _ => Err(CuptirError::CuptiNotSupported)?
                })
            }
        }
    }
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("cargo:rerun-if-changed=thirdparty/cudarc");

    let enabled_feature = enabled_cuda_feature().expect("no cuda version selected");

    let mut sys = File::open(
        PathBuf::from(std::env::var("CARGO_MANIFEST_DIR")?)
            .join("thirdparty/cudarc/src/cupti/sys/mod.rs"),
    )?;
    let mut sys_source = String::with_capacity(2 * 1024 * 1024);
    sys.read_to_string(&mut sys_source)?;
    let sys_source_parsed = syn::parse_file(sys_source.as_str())?;

    // Generate targets
    let root = PathBuf::from(std::env::var("OUT_DIR")?);
    let targets = [
        (
            generate_safe_enums(&sys_source_parsed, enabled_feature.as_str()),
            root.join("enums.rs"),
        ),
        (
            generate_function_param_structs(&sys_source_parsed, enabled_feature.as_str()),
            root.join("function_params.rs"),
        ),
    ];

    // Write targets
    for (tokens, path) in targets {
        let mut output = std::fs::File::create(path)?;
        let syntax_tree = syn::parse2(tokens)?;
        let target = prettyplease::unparse(&syntax_tree);
        write!(output, "{target}")?;
    }

    Ok(())
}
